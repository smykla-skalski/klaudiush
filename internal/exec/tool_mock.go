// Code generated by MockGen. DO NOT EDIT.
// Source: tool.go
//
// Generated by this command:
//
//	mockgen -source=tool.go -destination=tool_mock.go -package=exec
//

// Package exec is a generated GoMock package.
package exec

import (
	reflect "reflect"

	gomock "go.uber.org/mock/gomock"
)

// MockToolChecker is a mock of ToolChecker interface.
type MockToolChecker struct {
	ctrl     *gomock.Controller
	recorder *MockToolCheckerMockRecorder
	isgomock struct{}
}

// MockToolCheckerMockRecorder is the mock recorder for MockToolChecker.
type MockToolCheckerMockRecorder struct {
	mock *MockToolChecker
}

// NewMockToolChecker creates a new mock instance.
func NewMockToolChecker(ctrl *gomock.Controller) *MockToolChecker {
	mock := &MockToolChecker{ctrl: ctrl}
	mock.recorder = &MockToolCheckerMockRecorder{mock}
	return mock
}

// EXPECT returns an object that allows the caller to indicate expected use.
func (m *MockToolChecker) EXPECT() *MockToolCheckerMockRecorder {
	return m.recorder
}

// FindTool mocks base method.
func (m *MockToolChecker) FindTool(alternatives ...string) string {
	m.ctrl.T.Helper()
	varargs := []any{}
	for _, a := range alternatives {
		varargs = append(varargs, a)
	}
	ret := m.ctrl.Call(m, "FindTool", varargs...)
	ret0, _ := ret[0].(string)
	return ret0
}

// FindTool indicates an expected call of FindTool.
func (mr *MockToolCheckerMockRecorder) FindTool(alternatives ...any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "FindTool", reflect.TypeOf((*MockToolChecker)(nil).FindTool), alternatives...)
}

// IsAvailable mocks base method.
func (m *MockToolChecker) IsAvailable(tool string) bool {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "IsAvailable", tool)
	ret0, _ := ret[0].(bool)
	return ret0
}

// IsAvailable indicates an expected call of IsAvailable.
func (mr *MockToolCheckerMockRecorder) IsAvailable(tool any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "IsAvailable", reflect.TypeOf((*MockToolChecker)(nil).IsAvailable), tool)
}

// RequireTool mocks base method.
func (m *MockToolChecker) RequireTool(tool string) error {
	m.ctrl.T.Helper()
	ret := m.ctrl.Call(m, "RequireTool", tool)
	ret0, _ := ret[0].(error)
	return ret0
}

// RequireTool indicates an expected call of RequireTool.
func (mr *MockToolCheckerMockRecorder) RequireTool(tool any) *gomock.Call {
	mr.mock.ctrl.T.Helper()
	return mr.mock.ctrl.RecordCallWithMethodType(mr.mock, "RequireTool", reflect.TypeOf((*MockToolChecker)(nil).RequireTool), tool)
}
