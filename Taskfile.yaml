version: '3'

# Task runner configuration for klaudiush
# Uses mise for tool version management
# Run 'mise install' before running tasks

vars:
  BINARY_NAME: klaudiush
  INSTALL_DIR:
    sh: |
      if [ -d "$HOME/.local/bin" ]; then
        echo "$HOME/.local/bin"
      elif [ -d "$HOME/bin" ]; then
        echo "$HOME/bin"
      elif [ -d "$HOME/.bin" ]; then
        echo "$HOME/.bin"
      else
        echo "$HOME/.local/bin"
      fi
  INSTALL_PATH: '{{.INSTALL_DIR}}/klaudiush'

tasks:
  default:
    desc: Show available tasks
    cmds:
      - task --list

  generate:
    desc: Run all code generation (enums and mocks)
    cmds:
      - mise exec -- go generate ./...
    sources:
      - pkg/hook/context.go
      - pkg/config/types.go
      - pkg/logger/level.go
      - pkg/logger/logger.go
      - internal/git/runner.go
      - internal/exec/command.go
      - internal/exec/tool.go
      - internal/exec/tempfile.go
      - internal/linters/shellcheck.go
      - internal/linters/terraform.go
      - internal/linters/tflint.go
      - internal/linters/actionlint.go
      - internal/linters/markdownlint.go
      - internal/prompt/prompt.go
      - internal/validator/validator.go
      - internal/doctor/types.go
      - internal/doctor/checkers/config/config_check.go
    generates:
      # Enums
      - pkg/hook/eventtype_enumer.go
      - pkg/hook/tooltype_enumer.go
      - pkg/config/severity_enumer.go
      - pkg/logger/level_enumer.go
      # Mocks
      - pkg/logger/logger_mock.go
      - internal/git/runner_mock.go
      - internal/exec/command_mock.go
      - internal/exec/tool_mock.go
      - internal/exec/tempfile_mock.go
      - internal/linters/shellcheck_mock.go
      - internal/linters/terraform_mock.go
      - internal/linters/tflint_mock.go
      - internal/linters/actionlint_mock.go
      - internal/linters/markdownlint_mock.go
      - internal/prompt/prompt_mock.go
      - internal/validator/validator_mock.go
      - internal/doctor/types_mock.go
      - internal/doctor/checkers/config/config_loader_mock.go

  build:
    desc: Build the binary (without signoff validation)
    deps:
      - generate
    cmds:
      - mise exec -- go build -o bin/{{.BINARY_NAME}} ./cmd/klaudiush
    sources:
      - '**/*.go'
    generates:
      - bin/{{.BINARY_NAME}}

  build:prod:
    desc: Build production binary (same as build, signoff now configured via config file)
    cmds:
      - task: build

  test:
    desc: Run all tests with concise output (one line per package)
    deps:
      - build
    cmds:
      # Testscript tests (cmd/klaudiush) compile the binary inline.
      # CrowdStrike Falcon kills new executables under parallel load,
      # so these run separately with -p 1 (sequential).
      - mise exec -- go test -race -cover $(go list ./... | grep -v /cmd/klaudiush)
      - mise exec -- go test -race -cover -p 1 ./cmd/klaudiush

  test:verbose:
    desc: Run all tests with verbose output (shows each test)
    deps:
      - build
    cmds:
      - mise exec -- go test -v -race -cover $(go list ./... | grep -v /cmd/klaudiush)
      - mise exec -- go test -v -race -cover -p 1 ./cmd/klaudiush

  test:ginkgo:
    desc: Run ginkgo tests with ginkgo CLI (slower but prettier output)
    deps:
      - build
    cmds:
      - mise exec -- ginkgo -r -p --succinct --no-color --race --cover ./...

  test:unit:
    desc: Run unit tests only (short mode)
    cmds:
      - mise exec -- go test -race -cover -short $(go list ./... | grep -v /cmd/klaudiush)
      - mise exec -- go test -race -cover -short -p 1 ./cmd/klaudiush

  test:integration:
    desc: Run integration tests only
    cmds:
      - mise exec -- go test -race -cover -run Integration ./...

  test:testscript:
    desc: Run testscript integration tests (verbose)
    deps:
      - build
    cmds:
      - mise exec -- go test -v ./cmd/klaudiush -run 'TestScript.*'

  test:fuzz:
    desc: Run all fuzz tests (short duration for CI)
    vars:
      FUZZ_TIME: '{{.FUZZ_TIME | default "10s"}}'
    cmds:
      - mise exec -- go test -fuzz=FuzzParseGitCommand -fuzztime={{.FUZZ_TIME}} ./pkg/parser
      - mise exec -- go test -fuzz=FuzzBashParse -fuzztime={{.FUZZ_TIME}} ./pkg/parser
      - mise exec -- go test -fuzz=FuzzMdtableParse -fuzztime={{.FUZZ_TIME}} ./pkg/mdtable
      - mise exec -- go test -fuzz=FuzzJSONParse -fuzztime={{.FUZZ_TIME}} ./internal/parser
      - mise exec -- go test -fuzz=FuzzSecretsDetect -fuzztime={{.FUZZ_TIME}} ./internal/validators/secrets

  test:fuzz:git:
    desc: Run git parser fuzz test
    vars:
      FUZZ_TIME: '{{.FUZZ_TIME | default "60s"}}'
    cmds:
      - mise exec -- go test -fuzz=FuzzParseGitCommand -fuzztime={{.FUZZ_TIME}} ./pkg/parser

  test:fuzz:bash:
    desc: Run bash parser fuzz test
    vars:
      FUZZ_TIME: '{{.FUZZ_TIME | default "60s"}}'
    cmds:
      - mise exec -- go test -fuzz=FuzzBashParse -fuzztime={{.FUZZ_TIME}} ./pkg/parser

  test:fuzz:mdtable:
    desc: Run markdown table parser fuzz test
    vars:
      FUZZ_TIME: '{{.FUZZ_TIME | default "60s"}}'
    cmds:
      - mise exec -- go test -fuzz=FuzzMdtableParse -fuzztime={{.FUZZ_TIME}} ./pkg/mdtable

  test:fuzz:json:
    desc: Run JSON parser fuzz test
    vars:
      FUZZ_TIME: '{{.FUZZ_TIME | default "60s"}}'
    cmds:
      - mise exec -- go test -fuzz=FuzzJSONParse -fuzztime={{.FUZZ_TIME}} ./internal/parser

  test:fuzz:secrets:
    desc: Run secrets detector fuzz test
    vars:
      FUZZ_TIME: '{{.FUZZ_TIME | default "60s"}}'
    cmds:
      - mise exec -- go test -fuzz=FuzzSecretsDetect -fuzztime={{.FUZZ_TIME}} ./internal/validators/secrets

  lint:
    desc: Run linters on all files
    cmds:
      - mise exec -- golangci-lint cache clean
      - mise exec -- golangci-lint run

  lint:fix:
    desc: Run linters with auto-fix on all files
    cmds:
      - mise exec -- golangci-lint cache clean
      - mise exec -- golangci-lint run --fix



  check:
    desc: Lint and verify generated artifacts
    cmds:
      - task: lint:fix
      - task: schema:verify

  fmt:
    desc: Format code
    cmds:
      - mise exec -- golangci-lint run --fix

  install:
    desc: Install klaudiush binary to user PATH (~/.local/bin or ~/bin)
    deps:
      - build
    cmds:
      - mkdir -p {{.INSTALL_DIR}}
      - cp bin/{{.BINARY_NAME}} {{.INSTALL_PATH}}
      - chmod +x {{.INSTALL_PATH}}
      - echo "✓ Installed {{.BINARY_NAME}} to {{.INSTALL_PATH}}"
      - cmd: |
          if ! echo "$PATH" | grep -q "{{.INSTALL_DIR}}"; then
            echo ""
            echo "⚠️  Warning: {{.INSTALL_DIR}} is not in your PATH"
            echo "Add this to your shell profile (~/.bashrc, ~/.zshrc, etc.):"
            echo "  export PATH=\"{{.INSTALL_DIR}}:\$PATH\""
          fi
        silent: true

  install:hooks:
    desc: Install git hooks using lefthook
    cmds:
      - |
        if [ ! -d ".git" ]; then
          echo "Error: Not a git repository"
          exit 1
        fi
      - mise exec -- lefthook install
      - echo "✓ Git hooks installed via lefthook"

  uninstall:hooks:
    desc: Uninstall git hooks
    cmds:
      - mise exec -- lefthook uninstall
      - echo "✓ Git hooks uninstalled"

  clean:
    desc: Remove build artifacts
    cmds:
      - rm -rf bin/
      - rm -rf dist/
      - rm -rf build/

  deps:
    desc: Download dependencies
    cmds:
      - mise exec -- go mod download
      - mise exec -- go mod tidy

  schema:generate:
    desc: Generate versioned JSON Schema for config
    cmds:
      - mise exec -- go run ./cmd/schema-gen

  schema:verify:
    desc: Verify committed schema is up to date
    cmds:
      - mkdir -p /tmp/klaudiush-schema-check
      - mise exec -- go run ./cmd/schema-gen /tmp/klaudiush-schema-check
      - diff -u schema/ /tmp/klaudiush-schema-check/
      - rm -rf /tmp/klaudiush-schema-check

  verify:
    desc: Run all verification tasks
    cmds:
      - task: fmt
      - task: lint
      - task: test

  bench:
    desc: Run all benchmarks with memory reporting
    cmds:
      - mise exec -- go test -bench=. -benchmem -run='^$' -count=1 ./...

  bench:short:
    desc: Run benchmarks for hot paths only
    cmds:
      - mise exec -- go test -bench=. -benchmem -run='^$' -count=1 ./pkg/parser ./internal/parser ./internal/validator ./internal/dispatcher ./internal/validators/secrets

  bench:save:
    desc: Save benchmark results for comparison
    vars:
      BENCH_FILE: '{{.BENCH_FILE | default "bench-current.txt"}}'
    cmds:
      - mise exec -- go test -bench=. -benchmem -run='^$' -count=6 ./... | tee {{.BENCH_FILE}}

  bench:compare:
    desc: Compare saved benchmark results (requires benchstat)
    vars:
      OLD: '{{.OLD | default "bench-old.txt"}}'
      NEW: '{{.NEW | default "bench-current.txt"}}'
    cmds:
      - mise exec -- benchstat {{.OLD}} {{.NEW}}

  bench:report:
    desc: Run all benchmarks and save report to /tmp
    vars:
      REPORT_DIR: /tmp/klaudiush-bench
      TIMESTAMP:
        sh: date +%Y%m%dT%H%M%S
    cmds:
      - mkdir -p {{.REPORT_DIR}}
      - mise exec -- go test -bench=. -benchmem -run='^$' -count=6 -timeout=10m ./... 2>&1 | tee {{.REPORT_DIR}}/bench-{{.TIMESTAMP}}.txt
      - echo ""
      - echo "Report saved to {{.REPORT_DIR}}/bench-{{.TIMESTAMP}}.txt"

  bench:e2e:
    desc: Run end-to-end binary benchmarks (manual only, not run in CI)
    deps:
      - build
    cmds:
      - mise exec -- go test -tags=bench_e2e -bench=BenchmarkBinaryE2E -benchmem -run='^$' -count=3 -timeout=10m ./cmd/klaudiush

  bench:timing:
    desc: Run binary with internal timing instrumentation
    deps:
      - build
    vars:
      PAYLOAD: '{{.PAYLOAD | default "cmd/klaudiush/testdata/bench-payloads/git-commit-pass.json"}}'
    cmds:
      - cmd: echo '{}' | KLAUDIUSH_BENCH_TIMING=1 ./bin/klaudiush --hook-type PreToolUse 2>&1 >/dev/null || true
        silent: true
      - cmd: cat {{.PAYLOAD}} | KLAUDIUSH_BENCH_TIMING=1 ./bin/klaudiush --hook-type PreToolUse 2>&1 >/dev/null || true
        silent: true

  bench:hyperfine:
    desc: Run end-to-end benchmarks with hyperfine
    deps:
      - build
    cmds:
      - bash scripts/bench-e2e.sh ./bin/klaudiush
