# Codex Code Review workflow
# Runs Codex on pull requests when explicitly requested
# Posts inline review comments on specific lines in the diff

name: Codex Code Review

on:
  # Manual trigger from Actions UI
  workflow_dispatch:
    inputs:
      pr_number:
        description: "Pull request number to review"
        required: true
        type: number

  # Comment trigger for "/codex review" command
  issue_comment:
    types: [created]

permissions: {}

jobs:
  check-trigger:
    runs-on: ubuntu-24.04

    permissions:
      pull-requests: read
      issues: read

    outputs:
      should_run: ${{ steps.check.outputs.should_run }}
      pr_number: ${{ steps.check.outputs.pr_number }}

    steps:
      - name: Check trigger conditions
        id: check
        env:
          EVENT_NAME: ${{ github.event_name }}
          COMMENT_BODY: ${{ github.event.comment.body }}
          IS_PR_COMMENT: ${{ github.event.issue.pull_request != '' }}
          AUTHOR_ASSOCIATION: ${{ github.event.comment.author_association }}
          PR_NUMBER_INPUT: ${{ inputs.pr_number }}
          ISSUE_NUMBER: ${{ github.event.issue.number }}
        run: |
          should_run="false"
          pr_number=""

          case "$EVENT_NAME" in
            workflow_dispatch)
              should_run="true"
              pr_number="$PR_NUMBER_INPUT"
              ;;
            issue_comment)
              if [[ "$IS_PR_COMMENT" == "true" ]] && [[ "$AUTHOR_ASSOCIATION" =~ ^(OWNER|MEMBER|COLLABORATOR)$ ]] && grep -qiE '(^|\n)\s*/codex\s+review\s*($|\n)' <<< "$COMMENT_BODY"; then
                should_run="true"
                pr_number="$ISSUE_NUMBER"
              fi
              ;;
          esac

          echo "should_run=$should_run" >> "$GITHUB_OUTPUT"
          echo "pr_number=$pr_number" >> "$GITHUB_OUTPUT"

  codex-review:
    needs: check-trigger
    if: needs.check-trigger.outputs.should_run == 'true'
    runs-on: ubuntu-24.04

    permissions:
      contents: read
      pull-requests: write
      issues: write
      id-token: write

    steps:
      - name: Mint identity token
        id: mint_identity_token
        if: vars.CODEX_APP_ID
        uses: actions/create-github-app-token@7e473efe3cb98aa54f8d4bac15400b15fad77d94 # v2.2.0
        with:
          app-id: ${{ vars.CODEX_APP_ID }}
          private-key: ${{ secrets.CODEX_PRIVATE_KEY }}
          permission-contents: read
          permission-issues: write
          permission-pull-requests: write

      - name: Checkout PR merge commit
        uses: actions/checkout@1af3b93b6815bc44a9784bd300feb67ff0d1eeb3 # v6.0.0
        with:
          ref: refs/pull/${{ needs.check-trigger.outputs.pr_number }}/merge
          fetch-depth: 0

      - name: Get PR info and diff
        id: pr_info
        env:
          GH_TOKEN: ${{ steps.mint_identity_token.outputs.token || github.token }}
          PR_NUMBER: ${{ needs.check-trigger.outputs.pr_number }}
        run: |
          # Fetch PR metadata via gh CLI (safe - output goes through jq parsing)
          pr_info=$(gh pr view "$PR_NUMBER" --json headRefOid,baseRefName,headRefName,title,body)
          head_sha=$(echo "$pr_info" | jq -r '.headRefOid')
          base_ref=$(echo "$pr_info" | jq -r '.baseRefName')
          head_ref=$(echo "$pr_info" | jq -r '.headRefName')
          echo "head_sha=$head_sha" >> "$GITHUB_OUTPUT"
          echo "base_ref=$base_ref" >> "$GITHUB_OUTPUT"
          echo "head_ref=$head_ref" >> "$GITHUB_OUTPUT"
          git fetch --no-tags origin "$base_ref" "+refs/pull/${PR_NUMBER}/head:refs/remotes/origin/pull/${PR_NUMBER}/head"

          # Save PR context to files for Codex to read (sandbox has no network access)
          # Using jq -r to safely extract and write to files
          echo "$pr_info" | jq -r '.title' > pr-title.txt
          echo "$pr_info" | jq -r '.body // ""' > pr-body.txt
          gh pr diff "$PR_NUMBER" > pr-diff.txt
          gh pr view "$PR_NUMBER" --json files --jq '.files[].path' > pr-files.txt

      - name: Add eyes reaction and post working comment
        id: working_comment
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          PR_NUM: ${{ needs.check-trigger.outputs.pr_number }}
          TRIGGER_COMMENT_ID: ${{ github.event.comment.id }}
        with:
          github-token: ${{ steps.mint_identity_token.outputs.token || github.token }}
          script: |
            const prNumber = Number(process.env.PR_NUM);
            const commentId = process.env.TRIGGER_COMMENT_ID;

            // Add eyes reaction to the triggering comment
            if (commentId) {
              await github.rest.reactions.createForIssueComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                comment_id: Number(commentId),
                content: 'eyes'
              });
            }

            // Post working comment
            const { data: comment } = await github.rest.issues.createComment({
              owner: context.repo.owner,
              repo: context.repo.repo,
              issue_number: prNumber,
              body: '> ðŸ¤– **Codex** is reviewing this PR...\n\n<img src="https://github.githubassets.com/images/mona-loading-default.gif" width="32" alt="Loading" />'
            });
            return comment.id;
          result-encoding: string

      - name: Run Codex review with structured output
        id: run_codex
        uses: openai/codex-action@086169432f1d2ab2f4057540b1754d550f6a1189 # v1.4
        env:
          PR_NUMBER: ${{ needs.check-trigger.outputs.pr_number }}
          REPOSITORY: ${{ github.repository }}
        with:
          openai-api-key: ${{ secrets.OPENAI_API_KEY }}
          sandbox: read-only
          output-file: codex-review-output.json
          output-schema: |
            {
              "type": "object",
              "additionalProperties": false,
              "properties": {
                "findings": {
                  "type": "array",
                  "items": {
                    "type": "object",
                    "additionalProperties": false,
                    "properties": {
                      "title": {"type": "string"},
                      "body": {"type": "string"},
                      "priority": {"type": "integer"},
                      "code_location": {
                        "type": "object",
                        "additionalProperties": false,
                        "properties": {
                          "file_path": {"type": "string"},
                          "line_range": {
                            "type": "object",
                            "additionalProperties": false,
                            "properties": {
                              "start": {"type": "integer"},
                              "end": {"type": "integer"}
                            },
                            "required": ["start", "end"]
                          }
                        },
                        "required": ["file_path", "line_range"]
                      }
                    },
                    "required": ["title", "body", "priority", "code_location"]
                  }
                },
                "overall_correctness": {"type": "string"},
                "overall_explanation": {"type": "string"}
              },
              "required": ["findings", "overall_correctness", "overall_explanation"]
            }
          prompt: |
            You are Codex performing a code review for PR #${{ env.PR_NUMBER }} in ${{ env.REPOSITORY }}.

            PR context has been pre-fetched (network is unavailable in sandbox):
            - pr-title.txt: PR title
            - pr-body.txt: PR description
            - pr-diff.txt: Full diff of all changes
            - pr-files.txt: List of changed file paths

            You have full read access to the entire repository. Use this to understand context,
            existing patterns, and how the changes fit into the codebase.

            Review process:
            1. Read pr-diff.txt and pr-files.txt to see what changed
            2. Read the actual source files to understand the full context
            3. Explore related files to understand patterns and dependencies
            4. Identify significant issues

            Focus only on significant issues: correctness, security, performance, data races, and maintainability.
            Skip minor style nitpicks. Only report issues you are confident about.

            For each finding, provide:
            - A concise title (max 80 chars)
            - A detailed body explaining the issue and how to fix it
            - Priority: 0 (critical/blocking), 1 (high), 2 (medium), 3 (low)
            - The exact file path and line range where the issue occurs

      - name: Post inline review comments
        if: always() && steps.run_codex.outcome == 'success'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          PR_NUMBER: ${{ needs.check-trigger.outputs.pr_number }}
          HEAD_SHA: ${{ steps.pr_info.outputs.head_sha }}
          WORKING_COMMENT_ID: ${{ steps.working_comment.outputs.result }}
          TRIGGER_COMMENT_ID: ${{ github.event.comment.id }}
        with:
          github-token: ${{ steps.mint_identity_token.outputs.token || github.token }}
          script: |
            const fs = require('fs');
            const prNumber = Number(process.env.PR_NUMBER);
            const commitId = process.env.HEAD_SHA;
            const workingCommentId = process.env.WORKING_COMMENT_ID;
            const triggerCommentId = process.env.TRIGGER_COMMENT_ID;

            // Helper to clean up working comment
            async function cleanupWorkingComment() {
              if (workingCommentId) {
                try {
                  await github.rest.issues.deleteComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: Number(workingCommentId)
                  });
                } catch (err) {
                  core.warning(`Failed to delete working comment: ${err.message}`);
                }
              }
              // Remove eyes reaction from trigger comment
              if (triggerCommentId) {
                try {
                  const reactions = await github.rest.reactions.listForIssueComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: Number(triggerCommentId)
                  });
                  const eyesReaction = reactions.data.find(r => r.content === 'eyes');
                  if (eyesReaction) {
                    await github.rest.reactions.deleteForIssueComment({
                      owner: context.repo.owner,
                      repo: context.repo.repo,
                      comment_id: Number(triggerCommentId),
                      reaction_id: eyesReaction.id
                    });
                  }
                } catch (err) {
                  core.warning(`Failed to remove reaction: ${err.message}`);
                }
              }
            }

            // Read Codex output
            let output;
            try {
              const rawOutput = fs.readFileSync('codex-review-output.json', 'utf8');
              output = JSON.parse(rawOutput);
            } catch (err) {
              core.warning(`Failed to parse Codex output: ${err.message}`);
              await cleanupWorkingComment();
              return;
            }

            if (!output || !output.findings) {
              core.info('No findings in Codex output');
              // Post summary comment if there's an overall explanation
              if (output?.overall_explanation) {
                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `## Codex Code Review\n\nâœ… ${output.overall_explanation}`
                });
              }
              await cleanupWorkingComment();
              return;
            }

            // Build inline comments array
            const comments = output.findings
              .filter(f => f.code_location?.file_path && f.code_location?.line_range)
              .map(f => {
                const priorityLabels = ['ðŸ”´ P0 Critical', 'ðŸŸ  P1 High', 'ðŸŸ¡ P2 Medium', 'ðŸŸ¢ P3 Low'];
                const priorityLabel = priorityLabels[f.priority] || `P${f.priority}`;
                return {
                  path: f.code_location.file_path.replace(/^\//, ''),
                  line: f.code_location.line_range.end,
                  start_line: f.code_location.line_range.start !== f.code_location.line_range.end
                    ? f.code_location.line_range.start
                    : undefined,
                  side: 'RIGHT',
                  body: `**${f.title}** (${priorityLabel})\n\n${f.body}`
                };
              })
              .filter(c => c.path && c.line);

            // Determine review event based on findings
            const hasCritical = output.findings.some(f => f.priority === 0);
            let event = 'COMMENT';
            if (hasCritical) {
              event = 'REQUEST_CHANGES';
            }

            // Create review with inline comments
            if (comments.length > 0) {
              try {
                await github.rest.pulls.createReview({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  pull_number: prNumber,
                  commit_id: commitId,
                  event: event,
                  body: `## Codex Code Review\n\n${output.overall_explanation}\n\n_Found ${comments.length} issue(s) - see inline comments below._`,
                  comments: comments
                });
                core.info(`Created review with ${comments.length} inline comments`);
              } catch (err) {
                // If inline comments fail (e.g., line not in diff), fall back to regular comment
                core.warning(`Failed to create review with inline comments: ${err.message}`);
                const findingsText = output.findings.map(f => {
                  const priorityLabels = ['ðŸ”´ P0', 'ðŸŸ  P1', 'ðŸŸ¡ P2', 'ðŸŸ¢ P3'];
                  const loc = f.code_location;
                  return `### ${priorityLabels[f.priority] || 'P?'} ${f.title}\n\nðŸ“ \`${loc.file_path}:${loc.line_range.start}-${loc.line_range.end}\`\n\n${f.body}`;
                }).join('\n\n---\n\n');

                await github.rest.issues.createComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  issue_number: prNumber,
                  body: `## Codex Code Review\n\n${output.overall_explanation}\n\n---\n\n${findingsText}`
                });
              }
            } else if (output.overall_explanation) {
              // No inline findings - post summary comment
              await github.rest.issues.createComment({
                owner: context.repo.owner,
                repo: context.repo.repo,
                issue_number: prNumber,
                body: `## Codex Code Review\n\n${output.overall_explanation}`
              });
            }
            await cleanupWorkingComment();

      - name: Cleanup on failure
        if: always() && steps.run_codex.outcome != 'success'
        uses: actions/github-script@ed597411d8f924073f98dfc5c65a23a2325f34cd # v8.0.0
        env:
          PR_NUMBER: ${{ needs.check-trigger.outputs.pr_number }}
          WORKING_COMMENT_ID: ${{ steps.working_comment.outputs.result }}
          TRIGGER_COMMENT_ID: ${{ github.event.comment.id }}
        with:
          github-token: ${{ steps.mint_identity_token.outputs.token || github.token }}
          script: |
            const prNumber = Number(process.env.PR_NUMBER);
            const workingCommentId = process.env.WORKING_COMMENT_ID;
            const triggerCommentId = process.env.TRIGGER_COMMENT_ID;

            // Update working comment to show failure
            if (workingCommentId) {
              try {
                await github.rest.issues.updateComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: Number(workingCommentId),
                  body: 'âŒ Codex encountered an error while reviewing this PR.'
                });
              } catch (err) {
                core.warning(`Failed to update working comment: ${err.message}`);
              }
            }

            // Remove eyes reaction
            if (triggerCommentId) {
              try {
                const reactions = await github.rest.reactions.listForIssueComment({
                  owner: context.repo.owner,
                  repo: context.repo.repo,
                  comment_id: Number(triggerCommentId)
                });
                const eyesReaction = reactions.data.find(r => r.content === 'eyes');
                if (eyesReaction) {
                  await github.rest.reactions.deleteForIssueComment({
                    owner: context.repo.owner,
                    repo: context.repo.repo,
                    comment_id: Number(triggerCommentId),
                    reaction_id: eyesReaction.id
                  });
                }
              } catch (err) {
                core.warning(`Failed to remove reaction: ${err.message}`);
              }
            }
